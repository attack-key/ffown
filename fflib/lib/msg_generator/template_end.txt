
template<typename T, typename R>
int msg_dispather_t<T, R>::dispath(const string& json_, socket_ptr_t sock_)
{
    json_dom_t document;  // Default template parameter uses UTF8 and MemoryPoolAllocator.
    if (document.Parse<0>(json_.c_str()).HasParseError())
    {
        throw msg_exception_t("json format not right");
    }
    if (false == document.IsObject() && false == document.Empty())
    {
        throw msg_exception_t("json must has one field");
    }

    const json_value_t& val = document.MemberBegin()->name;
    const char* func_name   = val.GetString();
    typename map<string, reg_func_t>::const_iterator it = m_reg_func.find(func_name);

    if (it == m_reg_func.end())
    {
        char buff[512];
        snprintf(buff, sizeof(buff), "msg not supported<%s>", func_name);
        throw msg_exception_t(buff);
        return -1;
    }
    reg_func_t func = it->second;

    (this->*func)(document.MemberBegin()->value, sock_);
    return 0;
}